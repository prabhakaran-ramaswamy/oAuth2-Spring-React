{
	"info": {
		"_postman_id": "b2c3d4e5-f6g7-8901-bcde-fg2345678901",
		"name": "OAuth2 PKCE Authorization Code Grant Collection",
		"description": "Collection for testing OAuth 2.0 Authorization Code Grant with PKCE",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"auth": {
		"type": "noauth"
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// Generate PKCE code verifier and challenge",
					"const crypto = require('crypto-js');",
					"",
					"// Generate code verifier (43-128 characters)",
					"function generateCodeVerifier() {",
					"    const array = new Uint8Array(32);",
					"    crypto.lib.WordArray.random(32);",
					"    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';",
					"    let result = '';",
					"    for (let i = 0; i < 43; i++) {",
					"        result += charset[Math.floor(Math.random() * charset.length)];",
					"    }",
					"    return result;",
					"}",
					"",
					"// Generate code challenge from verifier",
					"function generateCodeChallenge(verifier) {",
					"    return crypto.SHA256(verifier).toString(crypto.enc.Base64url);",
					"}",
					"",
					"// Set PKCE values if not already set",
					"if (!pm.collectionVariables.get('code_verifier')) {",
					"    const codeVerifier = generateCodeVerifier();",
					"    const codeChallenge = generateCodeChallenge(codeVerifier);",
					"    ",
					"    pm.collectionVariables.set('code_verifier', codeVerifier);",
					"    pm.collectionVariables.set('code_challenge', codeChallenge);",
					"    ",
					"    console.log('Generated PKCE values:');",
					"    console.log('Code Verifier:', codeVerifier);",
					"    console.log('Code Challenge:', codeChallenge);",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "auth_server_url",
			"value": "http://localhost:8080",
			"type": "string"
		},
		{
			"key": "client_id",
			"value": "demo-client",
			"type": "string"
		},
		{
			"key": "redirect_uri",
			"value": "https://oauth.pstmn.io/v1/callback",
			"type": "string"
		},
		{
			"key": "scope",
			"value": "openid profile email read write",
			"type": "string"
		},
		{
			"key": "state",
			"value": "pkce-test-state-12345",
			"type": "string"
		},
		{
			"key": "code_verifier",
			"value": "",
			"type": "string"
		},
		{
			"key": "code_challenge",
			"value": "",
			"type": "string"
		},
		{
			"key": "authorization_code",
			"value": "",
			"type": "string"
		},
		{
			"key": "access_token",
			"value": "",
			"type": "string"
		},
		{
			"key": "refresh_token",
			"value": "",
			"type": "string"
		},
		{
			"key": "id_token",
			"value": "",
			"type": "string"
		}
	],
	"item": [
		{
			"name": "Step 1: Generate PKCE Values",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"// Manual PKCE generation if needed",
							"const crypto = require('crypto-js');",
							"",
							"function generateCodeVerifier() {",
							"    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';",
							"    let result = '';",
							"    for (let i = 0; i < 43; i++) {",
							"        result += charset[Math.floor(Math.random() * charset.length)];",
							"    }",
							"    return result;",
							"}",
							"",
							"function generateCodeChallenge(verifier) {",
							"    return crypto.SHA256(verifier).toString(crypto.enc.Base64url);",
							"}",
							"",
							"const codeVerifier = generateCodeVerifier();",
							"const codeChallenge = generateCodeChallenge(codeVerifier);",
							"",
							"pm.collectionVariables.set('code_verifier', codeVerifier);",
							"pm.collectionVariables.set('code_challenge', codeChallenge);",
							"",
							"console.log('✅ PKCE values generated successfully!');",
							"console.log('Code Verifier:', codeVerifier);",
							"console.log('Code Challenge:', codeChallenge);",
							"console.log('Code Challenge Method: S256');",
							"",
							"pm.test('PKCE values generated', function () {",
							"    pm.expect(codeVerifier).to.have.lengthOf.at.least(43);",
							"    pm.expect(codeChallenge).to.not.be.empty;",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "https://httpbin.org/status/200",
					"protocol": "https",
					"host": [
						"httpbin",
						"org"
					],
					"path": [
						"status",
						"200"
					]
				},
				"description": "This step generates PKCE code verifier and challenge values for the authorization flow."
			},
			"response": []
		},
		{
			"name": "Step 2: Authorization Request (PKCE)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"// This request should be opened in browser",
							"const authUrl = pm.request.url.toString();",
							"console.log('🌐 Open this URL in your browser:');",
							"console.log(authUrl);",
							"console.log('');",
							"console.log('Instructions:');",
							"console.log('1. Copy the URL above and open it in your browser');",
							"console.log('2. Login with: testuser / testpassword (or admin / admin)');",
							"console.log('3. After authorization, copy the \"code\" parameter from callback URL');",
							"console.log('4. Set the \"authorization_code\" variable with that value');",
							"console.log('5. Run Step 3 to exchange code for tokens');",
							"",
							"pm.test('Authorization URL generated', function () {",
							"    pm.expect(authUrl).to.include('code_challenge');",
							"    pm.expect(authUrl).to.include('code_challenge_method=S256');",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
						"type": "text"
					}
				],
				"url": {
					"raw": "{{auth_server_url}}/oauth2/authorize?response_type=code&client_id={{client_id}}&redirect_uri={{redirect_uri}}&scope={{scope}}&state={{state}}&code_challenge={{code_challenge}}&code_challenge_method=S256",
					"host": [
						"{{auth_server_url}}"
					],
					"path": [
						"oauth2",
						"authorize"
					],
					"query": [
						{
							"key": "response_type",
							"value": "code",
							"description": "Required. Must be 'code' for authorization code flow"
						},
						{
							"key": "client_id",
							"value": "{{client_id}}",
							"description": "Required. OAuth2 client identifier"
						},
						{
							"key": "redirect_uri",
							"value": "{{redirect_uri}}",
							"description": "Required. Callback URI after authorization"
						},
						{
							"key": "scope",
							"value": "{{scope}}",
							"description": "Optional. Space-separated list of scopes"
						},
						{
							"key": "state",
							"value": "{{state}}",
							"description": "Recommended. Random string for CSRF protection"
						},
						{
							"key": "code_challenge",
							"value": "{{code_challenge}}",
							"description": "Required for PKCE. SHA256 hash of code_verifier"
						},
						{
							"key": "code_challenge_method",
							"value": "S256",
							"description": "Required for PKCE. Always S256"
						}
					]
				},
				"description": "Step 2: Authorization Request with PKCE\n\nThis request initiates the OAuth2 authorization code flow with PKCE. Copy the generated URL and open it in a browser.\n\n**PKCE Parameters:**\n- code_challenge: SHA256 hash of the code_verifier\n- code_challenge_method: S256 (SHA256)\n\n**Instructions:**\n1. Copy the request URL and open in browser\n2. Login with testuser/testpassword or admin/admin\n3. Copy the 'code' parameter from callback URL\n4. Set authorization_code variable\n5. Run Step 3"
			},
			"response": []
		},
		{
			"name": "Step 3: Token Exchange (PKCE)",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"if (pm.response.code === 200) {",
							"    const response = pm.response.json();",
							"    ",
							"    // Save tokens to collection variables",
							"    pm.collectionVariables.set('access_token', response.access_token);",
							"    ",
							"    if (response.refresh_token) {",
							"        pm.collectionVariables.set('refresh_token', response.refresh_token);",
							"    }",
							"    ",
							"    if (response.id_token) {",
							"        pm.collectionVariables.set('id_token', response.id_token);",
							"    }",
							"    ",
							"    // Log token information",
							"    console.log('✅ PKCE Token exchange successful!');",
							"    console.log('Access Token:', response.access_token.substring(0, 50) + '...');",
							"    console.log('Token Type:', response.token_type);",
							"    console.log('Expires In:', response.expires_in + ' seconds');",
							"    ",
							"    if (response.refresh_token) {",
							"        console.log('Refresh Token:', response.refresh_token.substring(0, 50) + '...');",
							"    }",
							"    ",
							"    if (response.id_token) {",
							"        console.log('ID Token:', response.id_token.substring(0, 50) + '...');",
							"    }",
							"    ",
							"    if (response.scope) {",
							"        console.log('Granted Scopes:', response.scope);",
							"    }",
							"    ",
							"    pm.test('Access token received', function () {",
							"        pm.expect(response.access_token).to.exist;",
							"        pm.expect(response.token_type).to.eql('Bearer');",
							"    });",
							"    ",
							"} else {",
							"    console.log('❌ Token exchange failed');",
							"    console.log('Status:', pm.response.code);",
							"    console.log('Response:', pm.response.text());",
							"    ",
							"    pm.test('Token exchange failed', function () {",
							"        pm.expect.fail('Token exchange failed: ' + pm.response.text());",
							"    });",
							"}"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded",
						"type": "text"
					},
					{
						"key": "Accept",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "grant_type",
							"value": "authorization_code",
							"description": "Required. Must be 'authorization_code'",
							"type": "text"
						},
						{
							"key": "code",
							"value": "{{authorization_code}}",
							"description": "Required. Authorization code from Step 2",
							"type": "text"
						},
						{
							"key": "redirect_uri",
							"value": "{{redirect_uri}}",
							"description": "Required. Same as used in authorization request",
							"type": "text"
						},
						{
							"key": "client_id",
							"value": "{{client_id}}",
							"description": "Required. OAuth2 client identifier",
							"type": "text"
						},
						{
							"key": "code_verifier",
							"value": "{{code_verifier}}",
							"description": "Required for PKCE. Original code verifier",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{auth_server_url}}/oauth2/token",
					"host": [
						"{{auth_server_url}}"
					],
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "Step 3: Token Exchange with PKCE\n\nExchange the authorization code for access token using PKCE code verifier.\n\n**Prerequisites:**\n1. Must have completed Step 1 (PKCE generation)\n2. Must have completed Step 2 (Authorization)\n3. Must have set authorization_code variable\n\n**PKCE Security:**\n- Uses code_verifier instead of client_secret\n- Prevents authorization code interception attacks\n- Suitable for public clients (mobile apps, SPAs)\n\n**Request Body:**\n- grant_type: authorization_code\n- code: Authorization code from callback\n- redirect_uri: Same as authorization request\n- client_id: Public client identifier\n- code_verifier: Original PKCE verifier"
			},
			"response": []
		},
		{
			"name": "Step 4: Test UserInfo Endpoint",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"if (pm.response.code === 200) {",
							"    const userInfo = pm.response.json();",
							"    ",
							"    console.log('✅ UserInfo retrieved successfully!');",
							"    console.log('User Subject:', userInfo.sub);",
							"    console.log('User Info:', JSON.stringify(userInfo, null, 2));",
							"    ",
							"    pm.test('UserInfo retrieved', function () {",
							"        pm.expect(userInfo.sub).to.exist;",
							"    });",
							"    ",
							"} else {",
							"    console.log('❌ UserInfo request failed');",
							"    console.log('Status:', pm.response.code);",
							"    console.log('Response:', pm.response.text());",
							"    ",
							"    pm.test('UserInfo request failed', function () {",
							"        pm.expect.fail('UserInfo failed: ' + pm.response.text());",
							"    });",
							"}"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{access_token}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json",
						"type": "text"
					}
				],
				"url": {
					"raw": "{{auth_server_url}}/userinfo",
					"host": [
						"{{auth_server_url}}"
					],
					"path": [
						"userinfo"
					]
				},
				"description": "Step 4: Get User Information\n\nRetrieve user information using the access token obtained via PKCE flow.\n\n**Prerequisites:**\n1. Must have completed Step 3 (Token Exchange)\n2. Access token must be valid and not expired\n3. Token must have 'openid' scope for userinfo access\n\n**Authorization:**\n- Type: Bearer Token\n- Token: Uses the access_token from PKCE flow\n\n**Expected Response:**\n- 200 OK: User information returned\n- 401 Unauthorized: Token invalid or expired\n- 403 Forbidden: Token valid but missing 'openid' scope"
			},
			"response": []
		},
		{
			"name": "Step 5: Test Resource Server",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"if (pm.response.code === 200) {",
							"    const employees = pm.response.json();",
							"    ",
							"    console.log('✅ Resource server access successful!');",
							"    console.log('Employees count:', Array.isArray(employees) ? employees.length : 'N/A');",
							"    ",
							"    pm.test('Resource access granted', function () {",
							"        pm.response.to.have.status(200);",
							"    });",
							"    ",
							"} else {",
							"    console.log('❌ Resource server access failed');",
							"    console.log('Status:', pm.response.code);",
							"    console.log('Response:', pm.response.text());",
							"    ",
							"    pm.test('Resource access status', function () {",
							"        if (pm.response.code === 401) {",
							"            console.log('Token may be expired or invalid');",
							"        } else if (pm.response.code === 403) {",
							"            console.log('Token valid but insufficient permissions');",
							"        }",
							"        pm.expect(pm.response.code).to.be.oneOf([200, 401, 403]);",
							"    });",
							"}"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{access_token}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [
					{
						"key": "Accept",
						"value": "application/json",
						"type": "text"
					}
				],
				"url": {
					"raw": "http://localhost:8081/api/employees",
					"protocol": "http",
					"host": [
						"localhost"
					],
					"port": "8081",
					"path": [
						"api",
						"employees"
					]
				},
				"description": "Step 5: Access Resource Server\n\nTest accessing a resource server using the access token obtained via PKCE flow.\n\n**Prerequisites:**\n1. Must have completed Step 3 (Token Exchange)\n2. Resource server must be running on port 8081\n3. Access token must be valid and not expired\n\n**Authorization:**\n- Type: Bearer Token\n- Token: Uses the access_token from PKCE flow\n\n**Expected Response:**\n- 200 OK: Resource access granted\n- 401 Unauthorized: Token invalid or expired\n- 403 Forbidden: Token valid but insufficient permissions"
			},
			"response": []
		},
		{
			"name": "Step 6: Refresh Token",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"if (pm.response.code === 200) {",
							"    const response = pm.response.json();",
							"    ",
							"    // Update access token",
							"    pm.collectionVariables.set('access_token', response.access_token);",
							"    ",
							"    // Update refresh token if provided",
							"    if (response.refresh_token) {",
							"        pm.collectionVariables.set('refresh_token', response.refresh_token);",
							"    }",
							"    ",
							"    // Update ID token if provided",
							"    if (response.id_token) {",
							"        pm.collectionVariables.set('id_token', response.id_token);",
							"    }",
							"    ",
							"    console.log('✅ Token refresh successful!');",
							"    console.log('New Access Token:', response.access_token.substring(0, 50) + '...');",
							"    ",
							"    pm.test('Token refresh successful', function () {",
							"        pm.expect(response.access_token).to.exist;",
							"        pm.expect(response.token_type).to.eql('Bearer');",
							"    });",
							"    ",
							"} else {",
							"    console.log('❌ Token refresh failed');",
							"    console.log('Status:', pm.response.code);",
							"    console.log('Response:', pm.response.text());",
							"    ",
							"    pm.test('Token refresh failed', function () {",
							"        pm.expect.fail('Token refresh failed: ' + pm.response.text());",
							"    });",
							"}"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [
					{
						"key": "Content-Type",
						"value": "application/x-www-form-urlencoded",
						"type": "text"
					},
					{
						"key": "Accept",
						"value": "application/json",
						"type": "text"
					}
				],
				"body": {
					"mode": "urlencoded",
					"urlencoded": [
						{
							"key": "grant_type",
							"value": "refresh_token",
							"description": "Required. Must be 'refresh_token'",
							"type": "text"
						},
						{
							"key": "refresh_token",
							"value": "{{refresh_token}}",
							"description": "Required. Refresh token from token response",
							"type": "text"
						},
						{
							"key": "client_id",
							"value": "{{client_id}}",
							"description": "Required. OAuth2 client identifier",
							"type": "text"
						}
					]
				},
				"url": {
					"raw": "{{auth_server_url}}/oauth2/token",
					"host": [
						"{{auth_server_url}}"
					],
					"path": [
						"oauth2",
						"token"
					]
				},
				"description": "Step 6: Refresh Access Token\n\nUse the refresh token to obtain a new access token without requiring user re-authentication.\n\n**Prerequisites:**\n1. Must have a valid refresh_token from Step 3\n2. Refresh token must not be expired\n\n**PKCE Note:**\n- Refresh token requests don't require code_verifier\n- Only client_id is needed for public clients\n- No client_secret required\n\n**Request Body:**\n- grant_type: refresh_token\n- refresh_token: The refresh token from previous response\n- client_id: OAuth2 client identifier\n\n**Response:**\n- access_token: New access token\n- token_type: Usually 'Bearer'\n- expires_in: New token lifetime\n- refresh_token: May be a new refresh token\n- id_token: New ID token if OpenID Connect"
			},
			"response": []
		}
	]
}
